## 网易云音乐的首页部分功能实现

+  **适合人群**

  -  有html，css，javascript的基础， 刚刚学习完vue的基础语法，需要小项目对vue的知识或js知识巩固的人。

+ **前言**

  -  前面的部分只是纯Vue的语法，没有其他官方插件的引用，使用的大多是原生js 去实现功能。如果你感觉到理解有点困难，不一定是因为我的代码注释少，至少比较多的命名我都起的比较有语义。
     比较推荐的是先尝试写一下功能，再去进行优化。因为我一个上午写的300行代码，可能实际上注释了200行，最后就直接去掉了。我大可不必浪费这些功夫去进行重构，但本着对代码的追求还是不断地进行重构和优化，就算功能并不算多，但如果你好好地阅读这些代码，应该也能使你收获不少。我不是一个完美主义者，但要说如果我想得到更好的方法思路，我就会去做。
  - 这个项目是我js学完的几天后开始动手用脚手架搭Vue的环境写的，建议新手从首页开始看起，如果你能感觉到有些代码不是很合理或者并不够优雅，你可以试着去优化它，这是我第一个vue的项目，如果认真阅读了我的代码你应该能发现在这其中的成长。

+ **你能学到什么**
  - vuex 的 基本使用
    > 有人说vuex 就是个vue的全局变量管理，比喻很恰当，如果配合ajax进行页面渲染时，你应该不想在页面失活之后再重新进行请求。当使用了vue-router进行页面管理的时候，全局的状态管理也是必要的。

  - vue同级组件的通讯

    > 通过建立一个空的事件总线，子组件发送到父组件，父组件传到子组件完成同级组件的通讯。请结合实际代码理解。

  - vue-router的使用

    > 简单的路由渲染，详情查看router.index.js

  - axios 的 封装

    > 详情查看plugins/axios.js
  - vue 的 语法实例
   > 如何使用vue的语法

+ node版本

  > v12.16.2

+ **功能介绍**

  - 轮播图 与 两边的背景图片展示

    > - 先请求好轮播图的数据，将它保存到data里。自动只需操作DOM元素赋值背景图片即可。值得注意的是还有得将定时器的返回值返回，用以重新计算。当鼠标进入的时候，移除该定时器，鼠标移出的时候重新执行自动切换函数，并赋值用于保存该函数的值便于当移出鼠标时清理的是当前的计时器。
    >
    > - 鼠标切换背景图片，由于当初刚写这个项目的时候使用了Element-UI 的组件 ，导致这个功能的实现并不完美。原意是通过点击就直接切换背景图片。但始终没有这个效果，试过不少方法最后放弃了，改为mouseover，算半个实现把。

  - 播放

    > - 抽离了一个音乐参数赋值的函数，下一首，上一首都得改变参数对视图进行渲染，与播放器的src进行赋值。
    > - 将歌曲的索引全交由 modeJudge 模式判定函数实现。值得一提的是随机播放的功能，经过本人测试，在随机播放模式下，当你点击下一首随机播放的时候，它会存储当前的索引，点击上一首则回到最近的一个歌曲索引播放。结合这段看下代码应该就清楚了。当切换模式之后，清空该数组。
    > - 进度条通过比例进行控制，设置宽度的百分比即可。
    > - 缓冲条看不懂的上网搜索audio.buffered即可
    > - 图标拖动实现播放，点击的时候停止播放时间更新，播放器让它正常播放，拖动的同时更新现在的时间，松开再将当前的时间赋值给播放器，然后将标志变量更改为正常更新播放时间。
    > - 点击实现跳转播放，获取当前位置的宽度 / 总进度条宽度 ，得到该比例后乘音乐的总时间 得当前位置的音乐时间。再更新一下进度条与缓冲条。

  - 获取audio的duration之前为NaN的 Vue的解决方案 （此处可跳过，算是对坑做个总结）

    > 上网查了许多资料，都是说在重新设置src的时候先load重新加载一下。始终不经用，然后 durationchange 事件里 进行设置也始终不管用。 然后改变思路，使用v-if 渲染数据，终于正常显示了。

  - 新碟上架左右滑动功能

    > - 参考了网易云的HTML设计，从第二个开始展示，左边一个隐藏元素，右边两个隐藏元素。点击向右时，当前ul列表向左滑动一个宽度，使下一个ul列表的left为0表示显示，使下下一个ul列表放于一个宽度的右边。如此反复。
    >
    > - 美化设计，如不加transition 画面显示过于枯燥，加了之后得注意需要将上2个操作的DOM元素的transition变为0，你可以试试不加会有什么效果。

  - 播放列表

    > - 鼠标在列表里滚动事件，判断滚轮的方向，判断边界，鼠标向上，ul内容往下走。主要思路： 本次ul内容滑动的距离 / (ul内容能滑动的距离)   =  本次滚动条移动的距离 / (滚动条能移动的距离)
    > - 点击列表的滚动条事件 ，首先得判断滚动条是否该出现，ul列表是否有溢出。对该比例判断存在疑惑得往scrollHeight等等这些去搜索。当鼠标发生滚动事件时：滚动条该移动的距离 = 当前移动的Y - 鼠标按下的时候的Y  + 距离顶部边框的Y（此Y 得保存，确保这个值是正确的），注意边界条件的判断。
    > - 点击列表的项进行播放， 改变 歌曲索引，调用改变音乐参数函数，添加播放图标，同时移除之前的播放图标。

  - 登录

    > 只完善了手机号登录的功能，自动登录效果不用多余的去实现，后台传送的数据包含cookie，可自动保存。
    >
    > ​	思路：点击登录，将登录窗口显示出来，点击手机号登录，将当前视图隐藏，显示表单视图，点击登录时请求登录数据，同时将当前登录状态传入top.vue的组件用于数据渲染。 比较粗糙的是，我还没对输入进行校验，如果你想接着完善，可以自己动手做做。
  - ajax请求数据 插入加载动画
    > 此项目中的实例目前只存在于歌单页面里进行插入。一般的推荐歌单请求只有20条数据，照正常来说应该不必考虑，问题在于用户收藏等 的歌单里通常会有上200条数据，故加入动画。实现的方法是使用commponent :is 标签 去进行是否加载的判断。 在页面存入初始状态变量，等待该位置的数据请求完成后把该状态设置为插入动画不需加载状态。如果做到这里已经完成了一半，但此时会发现，Vuex缓存的变量还是再显示即便你已经让他的opacity变为0了这是为什么呢？如果你感觉到困惑，可以查阅 computed 属性的资料，然后给出解决方法，当然你也可以直接参照我的，在update的生命周期里再把他opactiy 置为1。 

+ **踩坑**

  由于接口进行了缓存处理，相同的 url 会在两分钟内只向网易服务器发一次请求，如果遇到不需要缓存结果的接口 , 可在请求 url 后面加一个时间戳参数使 url 不同。具体在node_modules/axios/lib/core/Axios.js下

  > utils.forEach(['delete', 'get', 'head', 'options'], function forEachMethodNoData(method) {
  >
  >  /*eslint func-names:0*/
  >
  >  Axios.prototype[method] = function(url, config) {
  >
  >   return this.request(utils.merge(config || {}, {
  >
  >    method: method,
  >
  >    url: url.indexOf('?') == '-1'?url+'?_=' + Date.now() :url + '&_=' + Date.now()
  >
  >   }));
  >
  >  };
  >
  > });

+ **杂谈**

- 重新续写之后 ，一路顺通的我，在打算开发第二个页面的时候迎来了问题。
- 第一个问题：当我发现组件在路由跳转时，被销毁，数据得重新请求的时候，我的登录模块即使渲染出来但他的值为空。一开始我以为可以通过Vue-router的设置去保留状态，尝试无果。大概想明白了，当路由跳转时，跳转之前的路由页面会销毁。尽管我可以通过重新请求数据，但我觉得我应该尝试一下高级点的技术。于是 我打算准备用VueX 重构一下 这些代码，尽管现在它不是很慢。

- 第二个问题：假如我沿着之前的思路重新请求数据，那么应该在何时重新请求呢？我该怎么让它知道什么时候该重新请求？如果通过设置vue-router守卫，在编码的问题上很有难度

通过引入状态管理Vuex 解决了以上两个问题

怎样让未被激活的组件提前接受到数据并保存，然后在进入页面的时候通过该数据进行渲染？一开始我的方向一直往这个方向去，直到在各种生命周期里调用nextTick回调尝试无果，在思考了一下，应该通过同级的路由在切换时把该索引传入需要信息的路由页面。



今天遇到个效果需要考虑同级组件与路由的传参问题。经过小的测试发现，当是路由的传参问题时，使用公共组件的发送与接收是失败的。当然未跳转时，我们想要的接收方的路由页面也接收不了，因为他的页面是销毁的。没有变量，没有方法。好了，这样子问题又回到上面的最后一句话了。顺带一提，当使用route实例的push方法传入对象进行跳转时params 不与 name同用则无任何属性。

上面的问题解决了，变量保存在vuex 的模块里已经可以实现，新的问题又出来了，当我点击别的歌单渲染没出来，因为我判断了是否是同一个歌单。但再次点击回去后，无法成功渲染，猜想是点击别的歌单详情页面时，该歌单刷新了歌单模块的状态。原本我通过页面销毁之前将该变量保存进该模块。猜想的解决方法：在保存变量时，判断是否是同一个歌单，如果不是 ，我们不需要改变他的渲染索引变量。尝试无果，页面销毁前，做不到。

尝试把Audio组件保存变量进模块，再判断。

上官方文档找解决方案，似乎getters 可以做到 一个模块里的状态 有多个组件需要共享，明天再测试。再仔细翻阅了下资料，发现上面描述的并不准确，如果该状态有多个组件需要共享，那么我们直接引用就可以了，他的关键点在于先处理该数据，就是store 里的 计算属性.。

结果困扰了我近一个上午的问题突然茅塞顿开，既然路由跳转时状态也会变，那就找不会变得组件保存该状态吧，比如播放器组件

开发至此发现 有关于Login 的信息的状态有许多地方需要复用，在登录模块结构上加上getter应该是个不错的选择。

然后发现加入getter是完全多次一举，如果把getter比喻成store实例的计算属性，那我根本不需要它的计算，我只是想要数据渲染罢了。所以直接取就是了。


今天做个占位图片，等待src 全部传入才可以展示。//后面做是做出来了，但我感觉没什么用。主要是我需要它请求之后保存这个状态，如果我非要这么做，那我每次切换回路由，它还是得重新加载吗，而我只需要它返回缓存得结果罢了。  

​                                              

今天上文档发现v-bind的妙用，呵呵，可能也是我太习惯用原生的js线性的去写。

### 官方文档如下写道

>  操作元素的 class 列表和内联样式是数据绑定的一个常见需求。因为它们都是 attribute，所以我们可以用 `v-bind` 处理它们：只需要通过表达式计算出字符串结果即可。不过，字符串拼接麻烦且易错。

而我原本得方法照着样子看越看越觉得不行，先把它记录下来，等有时间了就给它重构一下。



```javascript
setRed(songindex){
      console.log(this.isSamePlaylist())
      if(this.isSamePlaylist()){
        let songIndexNode = document.getElementsByClassName('songplay');
        if(songIndexNode === undefined){
          return;
        }
        if(this.lastIndex != -1){
          songIndexNode[this.lastIndex].firstChild.classList.remove('red')    
        }
        songIndexNode[songindex].firstChild.classList.add('red');
        if(this.lastIndex != songindex){
          this.lastIndex = songindex
        }
}      
```

这段代码的核心其实就是对元素的类的类名添加移除，同时如果之前有播放的未被删除的，它的类名删除并记录当前播放的索引设置为上一次的索引。（怎么感觉有点绕?）简单的说就是，上一次添加的类名我们得把他删除。尽管我觉得这代码的可读性也不差，vbind如果要做到这个，明显要更直白。我们只需要保存并更新一个显示状态变量，至于移除和删除的操作不需我们自己去取节点。但可以预见的是，如果我们将该变量保存进vuex里面，我们在退出当前路由的时候应该及时把该模块的显示状态变量给清除，而在下一次进入的时候，进行赋值。                                         



突然想到登录页面写死并不太合适，我应该把登录状态与不登录状态的html界面分离，而不是单单的写入登录状态而把他设置为display：none；这个好办，在获取到登录状态为登录中时用ES6的模板字符串轻松插入，同时得移除之前的页面。                                                                    2020/12/9

发现一个比较重要的BUG？：点击歌单的时候，载入动画，明明已经设置了opacity：0 ，可是依然会有数据展示，而且是之前的数据。猜想: computed 应该是页面渲染，DOM挂载后才执行的，所以我这个设置其实毫无用处。该怎么解决呢？

解决方法： 把opacity  设置为1  放到更新的生命周期里。                              2020/12/10
